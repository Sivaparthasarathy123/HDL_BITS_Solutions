module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); 
    parameter [1:0] START    = 2'b00,
                    DATA     = 2'b01,
                    STOP     = 2'b10,
                    ERROR    = 2'b11;
    reg [1:0]state,next_state;
    reg [3:0]count;
    reg [7:0]out_byte1;
    always@(*)begin
        case(state)
            START : next_state = in ? START : DATA;
            DATA  : next_state = count<8 ? DATA : (in ? STOP : ERROR);
            STOP  : next_state = in ? START : DATA;
            ERROR : next_state = in ? START : ERROR;
            default:next_state = START;
        endcase
    end
    
    always@(posedge clk)begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    integer i;
    always@(posedge clk)begin
        if(reset)begin
            count <= 4'd0;
                 i<=0;
        end
       else if (state == DATA)begin
            count <= count + 1'b1;
               out_byte1[i] <= in;
                i<=i+1;
            end
        else begin 
            count <= 4'd0; 
            i<=0; 
        end
    end
    
    assign done = (state == STOP);
    assign out_byte = done ? out_byte1 : 8'b0; 
        
endmodule

